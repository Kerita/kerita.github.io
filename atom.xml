<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Kerita</title>
  <icon>https://kerita.me/icon.webp</icon>
  <subtitle>自律谦逊，承担责任，推迟满足感，你要热爱它</subtitle>
  <link href="https://kerita.me/atom.xml" rel="self"/>
  
  <link href="https://kerita.me/"/>
  <updated>2021-11-04T13:53:25.309Z</updated>
  <id>https://kerita.me/</id>
  
  <author>
    <name>Kerita</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>4-ts--TypeScript</title>
    <link href="https://kerita.me/11/04/fe-advance/4-ts/"/>
    <id>https://kerita.me/11/04/fe-advance/4-ts/</id>
    <published>2021-11-04T00:00:00.000Z</published>
    <updated>2021-11-04T13:53:25.309Z</updated>
    
    
    <summary type="html">&lt;p&gt;TypeScript 是一种类型安全的 JavaScript 语言，以下使用 TS 进行代称，使用的 TS 的好处如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;引入静态类型声明，减少不必要的类型判断和文档注释；&lt;/li&gt;
&lt;li&gt;及早发现错误，静态类型检查 1 或编译时发现问题，不用等到运行；&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="前端进击" scheme="https://kerita.me/categories/%E5%89%8D%E7%AB%AF%E8%BF%9B%E5%87%BB/"/>
    
    
  </entry>
  
  <entry>
    <title>2-各种模块化标准</title>
    <link href="https://kerita.me/11/01/fe-advance/2-module/"/>
    <id>https://kerita.me/11/01/fe-advance/2-module/</id>
    <published>2021-11-01T00:00:00.000Z</published>
    <updated>2021-11-04T13:53:25.309Z</updated>
    
    
    <summary type="html">&lt;p&gt;前端有各种模块化标注 AMD/CMD/CommonJS/ES6 module，各种模块化标准实现各有不同。&lt;/p&gt;</summary>
    
    
    
    <category term="前端进阶" scheme="https://kerita.me/categories/%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6/"/>
    
    
  </entry>
  
  <entry>
    <title>3-浏览器详解</title>
    <link href="https://kerita.me/11/01/fe-advance/3-browser/"/>
    <id>https://kerita.me/11/01/fe-advance/3-browser/</id>
    <published>2021-11-01T00:00:00.000Z</published>
    <updated>2021-11-04T13:53:25.309Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;浏览器对象&quot;&gt;&lt;a href=&quot;#浏览器对象&quot; class=&quot;headerlink&quot; title=&quot;浏览器对象&quot;&gt;&lt;/a&gt;浏览器对象&lt;/h2&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>1-了解 Promise</title>
    <link href="https://kerita.me/09/29/fe-advance/1-promise/"/>
    <id>https://kerita.me/09/29/fe-advance/1-promise/</id>
    <published>2021-09-29T00:00:00.000Z</published>
    <updated>2021-11-04T13:53:25.309Z</updated>
    
    
    <summary type="html">&lt;p&gt;Promise 是 ES6 内置的对象，用一个对象实例表示某个操作最终是成功或者失败，并且将成功值或者原因暴露出来，它主要解决了异步编程过程中存在的两个问题：&lt;br&gt;1.回调地狱问题&lt;br&gt;2.信任问题&lt;/p&gt;</summary>
    
    
    
    <category term="前端进阶" scheme="https://kerita.me/categories/%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6/"/>
    
    
  </entry>
  
  <entry>
    <title>前端如何建立 websocket 连接</title>
    <link href="https://kerita.me/09/17/2021/websocket/"/>
    <id>https://kerita.me/09/17/2021/websocket/</id>
    <published>2021-09-17T00:00:00.000Z</published>
    <updated>2021-11-04T13:53:25.301Z</updated>
    
    
      
      
        
        
    <summary type="html"></summary>
        
      
    
    
    
    <category term="js" scheme="https://kerita.me/categories/js/"/>
    
    
  </entry>
  
  <entry>
    <title>Hooks 组件的有点</title>
    <link href="https://kerita.me/09/16/dive-in-react/hooks/"/>
    <id>https://kerita.me/09/16/dive-in-react/hooks/</id>
    <published>2021-09-16T00:00:00.000Z</published>
    <updated>2021-11-04T13:53:25.309Z</updated>
    
    
    <summary type="html">&lt;p&gt;Hooks 是 React 16.8 版本新出的功能，比 class 具有很多优点。&lt;/p&gt;</summary>
    
    
    
    <category term="深入浅出 React" scheme="https://kerita.me/categories/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA-React/"/>
    
    
  </entry>
  
  <entry>
    <title>React 优化技巧</title>
    <link href="https://kerita.me/09/16/dive-in-react/optimize/"/>
    <id>https://kerita.me/09/16/dive-in-react/optimize/</id>
    <published>2021-09-16T00:00:00.000Z</published>
    <updated>2021-11-04T13:53:25.309Z</updated>
    
    
    <summary type="html">&lt;p&gt;使用一些技巧优化 React 性能。&lt;/p&gt;</summary>
    
    
    
    <category term="深入浅出 React" scheme="https://kerita.me/categories/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA-React/"/>
    
    
  </entry>
  
  <entry>
    <title>webpack 优化策略</title>
    <link href="https://kerita.me/09/15/webpack/optimize/"/>
    <id>https://kerita.me/09/15/webpack/optimize/</id>
    <published>2021-09-15T00:00:00.000Z</published>
    <updated>2021-11-04T13:53:25.349Z</updated>
    
    
    <summary type="html">&lt;p&gt;优化 webpack 配置，提高打包速度，减少打包体积。&lt;/p&gt;</summary>
    
    
    
    <category term="webpack" scheme="https://kerita.me/categories/webpack/"/>
    
    
  </entry>
  
  <entry>
    <title>webpack Scope Hoisting 配置</title>
    <link href="https://kerita.me/08/24/webpack/scope-hoisting/"/>
    <id>https://kerita.me/08/24/webpack/scope-hoisting/</id>
    <published>2021-08-24T00:00:00.000Z</published>
    <updated>2021-11-04T13:53:25.349Z</updated>
    
    
      
      
        
        
    <summary type="html"></summary>
        
      
    
    
    
    <category term="webpack" scheme="https://kerita.me/categories/webpack/"/>
    
    
  </entry>
  
  <entry>
    <title>webpack chunk 与 bundle</title>
    <link href="https://kerita.me/08/23/webpack/chunk-bundle/"/>
    <id>https://kerita.me/08/23/webpack/chunk-bundle/</id>
    <published>2021-08-23T00:00:00.000Z</published>
    <updated>2021-11-04T13:53:25.349Z</updated>
    
    
    <summary type="html">&lt;p&gt;chunk 和 bundle 都是 webpack 的重要概念，今天我们来理解它们。&lt;/p&gt;</summary>
    
    
    
    <category term="webpack" scheme="https://kerita.me/categories/webpack/"/>
    
    
  </entry>
  
  <entry>
    <title>webpack entry 配置</title>
    <link href="https://kerita.me/08/23/webpack/entry/"/>
    <id>https://kerita.me/08/23/webpack/entry/</id>
    <published>2021-08-23T00:00:00.000Z</published>
    <updated>2021-11-04T13:53:25.349Z</updated>
    
    
    <summary type="html">&lt;p&gt;entry 是 webpack 打包项目的入口，可配置打包单个文件或者文件，可使用 dependOn 与其他 入口 chunk 共享模块。&lt;/p&gt;</summary>
    
    
    
    <category term="webpack" scheme="https://kerita.me/categories/webpack/"/>
    
    
  </entry>
  
  <entry>
    <title>webpack hash, chunkhash, contenthash 区别</title>
    <link href="https://kerita.me/08/23/webpack/hash-chunkhash-contenthash/"/>
    <id>https://kerita.me/08/23/webpack/hash-chunkhash-contenthash/</id>
    <published>2021-08-23T00:00:00.000Z</published>
    <updated>2021-11-04T13:53:25.349Z</updated>
    
    
    <summary type="html">&lt;p&gt;当我们对 webpack output 的 filename 和 chunkFilename 配置时，使用合理的 hash 值有利于浏览器的缓存，减少二次加载时的文件数量。&lt;/p&gt;
&lt;p&gt;filename 是对打包后 bundle 名称进行配置，chunkFilename 是对切割出来的 chunk 名称进行配置。&lt;/p&gt;</summary>
    
    
    
    <category term="webpack" scheme="https://kerita.me/categories/webpack/"/>
    
    
  </entry>
  
  <entry>
    <title>Webpack Tree Shaking 配置</title>
    <link href="https://kerita.me/08/17/webpack/tree-shaking/"/>
    <id>https://kerita.me/08/17/webpack/tree-shaking/</id>
    <published>2021-08-17T00:00:00.000Z</published>
    <updated>2021-11-04T13:53:25.349Z</updated>
    
    
    <summary type="html">&lt;p&gt;Tree Shaking 翻译过来就是“摇树”。我们可以想象一下，对着一棵梨树的树干摇一摇，树上成熟的梨子就会掉下来。webpack 使用 Tree Shaking 处理代码，结合 ES6 模块静态引入依赖关系确定的特点，对代码进行静态分析，将那些没有用到的代码（Dead Code）“摇出来”——删掉。&lt;/p&gt;</summary>
    
    
    
    <category term="webpack" scheme="https://kerita.me/categories/webpack/"/>
    
    
  </entry>
  
  <entry>
    <title>Object，Map，Set 区别</title>
    <link href="https://kerita.me/08/13/ES6/obj-map-set/"/>
    <id>https://kerita.me/08/13/ES6/obj-map-set/</id>
    <published>2021-08-13T00:00:00.000Z</published>
    <updated>2021-11-04T13:53:25.301Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;Object&quot;&gt;&lt;a href=&quot;#Object&quot; class=&quot;headerlink&quot; title=&quot;Object&quot;&gt;&lt;/a&gt;Object&lt;/h2&gt;&lt;p&gt;Object 是 key-value 的数据结构，与 JSON 结构一样。&lt;a href=&quot;https://codesandbox.io/s/object-nku94?file=/index.html:659-691&quot;&gt;点击链接可查看以下示例&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;记录器&lt;br&gt;有时候我们也把 Object 当做一个记录器，例如记录某个列表的状态。&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;   const list &amp;#x3D; [&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       id: 1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       id: 2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   ];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   const obj &amp;#x3D; &amp;#123;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   list.forEach((item) &amp;#x3D;&amp;gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     obj[item.id] &amp;#x3D; item.id &amp;gt; 1 ? true : false;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;console.log(obj); &amp;#x2F;&amp;#x2F; &amp;#123;1: false, 2: true&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="ES6" scheme="https://kerita.me/categories/ES6/"/>
    
    
  </entry>
  
  <entry>
    <title>什么是 Redux——1</title>
    <link href="https://kerita.me/08/10/dive-in-react/18-redux/"/>
    <id>https://kerita.me/08/10/dive-in-react/18-redux/</id>
    <published>2021-08-10T00:00:00.000Z</published>
    <updated>2021-11-04T13:53:25.305Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;什么是-Flux&quot;&gt;&lt;a href=&quot;#什么是-Flux&quot; class=&quot;headerlink&quot; title=&quot;什么是 Flux&quot;&gt;&lt;/a&gt;什么是 Flux&lt;/h2&gt;&lt;p&gt;Flux 是 Facebook 用来构建客户端渲染 web 应用的应用框架。Flux 最重要的概念就是单向数据流，Flux 使用单向数据流来补充 React 的可组合式组件。相比一个正式的框架，它更像一种范式和思想，Redux 则是这种范式和思想的具体实现，当然 Redux 不严格遵循 Flux 的设定。&lt;/p&gt;
&lt;p&gt;Flux 具有严格的单向数据流，Store 里数据的变化，只能是由 Dispatcher 派发的 Action 触发的。这保证了应用的状态是可预测的，避免了应用混乱的情况，让整个流程变得清晰简单。&lt;/p&gt;
&lt;p&gt;当然，严格的单向数据流一方面增加开发者的学习成本，另一方面也增加了代码量，所以往往复杂的项目才需要使用 Flux 架构。&lt;/p&gt;</summary>
    
    
    
    <category term="深入浅出 React" scheme="https://kerita.me/categories/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA-React/"/>
    
    
  </entry>
  
  <entry>
    <title>Redux createStore 源码</title>
    <link href="https://kerita.me/08/10/read-source-code/redux-createStore/"/>
    <id>https://kerita.me/08/10/read-source-code/redux-createStore/</id>
    <published>2021-08-10T00:00:00.000Z</published>
    <updated>2021-11-04T13:53:25.345Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;参数传递&quot;&gt;&lt;a href=&quot;#参数传递&quot; class=&quot;headerlink&quot; title=&quot;参数传递&quot;&gt;&lt;/a&gt;参数传递&lt;/h2&gt;&lt;p&gt;Redux createStore 是 Redux 初始化函数，在参数传递时有个有意思的实现。&lt;/p&gt;
&lt;p&gt;判断 &lt;code&gt;preloadState&lt;/code&gt; 是否为函数，如果为函数将其作为 &lt;code&gt;enhancer&lt;/code&gt; 处理，并重新赋值 &lt;code&gt;preloadState&lt;/code&gt; 为 &lt;code&gt;undefined&lt;/code&gt;。&lt;/p&gt;</summary>
    
    
    
    <category term="源码阅读" scheme="https://kerita.me/categories/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
    
  </entry>
  
  <entry>
    <title>关于的 Flux 的几个概念</title>
    <link href="https://kerita.me/08/08/2021/flux-concepts/"/>
    <id>https://kerita.me/08/08/2021/flux-concepts/</id>
    <published>2021-08-08T00:00:00.000Z</published>
    <updated>2021-11-04T13:53:25.297Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;flux-concepts&quot;&gt;&lt;a href=&quot;#flux-concepts&quot; class=&quot;headerlink&quot; title=&quot;flux-concepts&quot;&gt;&lt;/a&gt;flux-concepts&lt;/h1&gt;&lt;p&gt;These are the important high-level concepts and principles you should know&lt;br&gt;about when writing applications that use Flux.&lt;/p&gt;</summary>
    
    
    
    <category term="React" scheme="https://kerita.me/categories/React/"/>
    
    
  </entry>
  
  <entry>
    <title>sourceType 错误</title>
    <link href="https://kerita.me/08/03/2021/babel-sourceType/"/>
    <id>https://kerita.me/08/03/2021/babel-sourceType/</id>
    <published>2021-08-03T00:00:00.000Z</published>
    <updated>2021-11-04T13:53:25.281Z</updated>
    
    
    <summary type="html">&lt;p&gt;升级 Babel 配置过程除了遇到 &lt;a href=&quot;/07/30/2021/replaceAll-is-not-a-function/#more&quot;&gt;&lt;code&gt;replaceAll-is-not-a-function&lt;/code&gt;&lt;/a&gt; 问题，还遇到关于 Babel sourceType 配置的问题。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>React 合成事件源码阅读</title>
    <link href="https://kerita.me/08/03/read-source-code/react-event/"/>
    <id>https://kerita.me/08/03/read-source-code/react-event/</id>
    <published>2021-08-03T00:00:00.000Z</published>
    <updated>2021-11-04T13:53:25.345Z</updated>
    
    
    <summary type="html">&lt;p&gt;React 合成事件是基于事件委托机制，构建的自定义事件体系。将需要监听的事件类型都收集起来放在 document 元素上，待事件触发通过 &lt;code&gt;event.target&lt;/code&gt; 将事件分发给相关元素。&lt;/p&gt;
&lt;p&gt;以下是分发时收集相关元素代码，包括两次遍历和获取父元素：&lt;/p&gt;</summary>
    
    
    
    <category term="源码阅读" scheme="https://kerita.me/categories/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
    
  </entry>
  
  <entry>
    <title>setState 源码阅读</title>
    <link href="https://kerita.me/08/03/read-source-code/setState/"/>
    <id>https://kerita.me/08/03/read-source-code/setState/</id>
    <published>2021-08-03T00:00:00.000Z</published>
    <updated>2021-11-04T13:53:25.345Z</updated>
    
    
    <summary type="html">&lt;p&gt;在理解&lt;a href=&quot;/07/29/dive-in-react/11-setState/&quot;&gt;setState 是同步还是异步的&lt;/a&gt; 时，梳理下 setState 的源码逻辑，如下：&lt;/p&gt;</summary>
    
    
    
    <category term="源码阅读" scheme="https://kerita.me/categories/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
    
  </entry>
  
</feed>
