<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Kerita</title>
  <icon>https://kerita.me/icon.webp</icon>
  <subtitle>自律谦逊，承担责任，推迟满足感，你要热爱它</subtitle>
  <link href="https://kerita.me/atom.xml" rel="self"/>
  
  <link href="https://kerita.me/"/>
  <updated>2021-08-01T13:18:48.593Z</updated>
  <id>https://kerita.me/</id>
  
  <author>
    <name>Kerita</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>什么是微前端</title>
    <link href="https://kerita.me/08/01/2021/micro-fe/"/>
    <id>https://kerita.me/08/01/2021/micro-fe/</id>
    <published>2021-08-01T00:00:00.000Z</published>
    <updated>2021-08-01T13:18:48.593Z</updated>
    
    
    <summary type="html">&lt;p&gt;微前端的理念源自微服务，使用一个主应用作为主体框架和微应用加载器，根据不用的路由加载不同的微应用。微应用之间做到技术隔离，在展示上却是统一的。&lt;/p&gt;
&lt;p&gt;微前端主要用来解决单体应用在相对长的时间跨度下，从一个普通应用变成一个巨石应用(Frontend Monolith)后，随着而来的应用不可维护问题。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>从 replaceAll is not a function 说起</title>
    <link href="https://kerita.me/07/30/2021/replaceAll-is-not-a-function/"/>
    <id>https://kerita.me/07/30/2021/replaceAll-is-not-a-function/</id>
    <published>2021-07-30T00:00:00.000Z</published>
    <updated>2021-08-01T13:18:48.593Z</updated>
    
    
    <summary type="html">&lt;p&gt;开发一个项目的时候，发现 @babel/preset-env 的配置如下：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#39;@babel&amp;#x2F;preset-env&amp;#39;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    useBuiltIns: false,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    targets: &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      chrome: 43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;],&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;使用这种配置，没有利用 &lt;code&gt;@babel/preset-env&lt;/code&gt; 根据 &lt;code&gt;targets&lt;/code&gt; 自动引入 polyfill 的能力，而是开发者手动引入。&lt;/p&gt;</summary>
    
    
    
    <category term="Babel" scheme="https://kerita.me/categories/Babel/"/>
    
    
  </entry>
  
  <entry>
    <title>setState 是同步还是异步的</title>
    <link href="https://kerita.me/07/29/dive-in-react/11-setState/"/>
    <id>https://kerita.me/07/29/dive-in-react/11-setState/</id>
    <published>2021-07-29T00:00:00.000Z</published>
    <updated>2021-08-01T13:18:48.597Z</updated>
    
    
    <summary type="html">&lt;p&gt;在我们使用 class 组件时，基本都会使用到 setState，因为唯有使用 setState 更新数据，才能实现数据驱动视图的效果。&lt;/p&gt;</summary>
    
    
    
    <category term="深入浅出 React" scheme="https://kerita.me/categories/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA-React/"/>
    
    
  </entry>
  
  <entry>
    <title>React 15 的调和</title>
    <link href="https://kerita.me/07/28/dive-in-react/10-reconciliation/"/>
    <id>https://kerita.me/07/28/dive-in-react/10-reconciliation/</id>
    <published>2021-07-28T00:00:00.000Z</published>
    <updated>2021-08-01T13:18:48.597Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;什么是调和（Reconciliation）&quot;&gt;&lt;a href=&quot;#什么是调和（Reconciliation）&quot; class=&quot;headerlink&quot; title=&quot;什么是调和（Reconciliation）&quot;&gt;&lt;/a&gt;什么是调和（Reconciliation）&lt;/h2&gt;&lt;p&gt;React 官方文档如是说：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Virtual DOM 是一种编程概念。在这个概念里，UI 以一种理想化的，或者说“虚拟的”表现形式被保存于内存中，并通过如 ReactDOM 等类库使之与“真实的” DOM 同步。这一过程叫作协调（调和）。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Diff 则是调和过程最重要部分。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>React 的虚拟 DOM</title>
    <link href="https://kerita.me/07/28/dive-in-react/9-virtual-dom/"/>
    <id>https://kerita.me/07/28/dive-in-react/9-virtual-dom/</id>
    <published>2021-07-28T00:00:00.000Z</published>
    <updated>2021-08-01T13:18:48.601Z</updated>
    
    
    <summary type="html">&lt;p&gt;虚拟 DOM 是使用 JS 对象来描述真实 DOM 结构。在数据发生改变时，虚拟 DOM 也发生改变，通过对比新旧虚拟 DOM 结构(diff)，找出二者差异，对真实 DOM 结构做更新(patch)。&lt;/p&gt;</summary>
    
    
    
    <category term="深入浅出 React" scheme="https://kerita.me/categories/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA-React/"/>
    
    
  </entry>
  
  <entry>
    <title>React Hooks 设计思想</title>
    <link href="https://kerita.me/07/27/dive-in-react/6-hooks/"/>
    <id>https://kerita.me/07/27/dive-in-react/6-hooks/</id>
    <published>2021-07-27T00:00:00.000Z</published>
    <updated>2021-08-01T13:18:48.601Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;什么是-Hooks&quot;&gt;&lt;a href=&quot;#什么是-Hooks&quot; class=&quot;headerlink&quot; title=&quot;什么是 Hooks&quot;&gt;&lt;/a&gt;什么是 Hooks&lt;/h2&gt;&lt;p&gt;Hooks 是 React 16.8 版本出现的特性，它是诸如 useState、useEffect 等一系列钩子函数。Hooks 的出现开发者在不需要写 class 组件时，也能具有 state 和其他 React 特性，函数组件从 stateless 变成 stateful。&lt;/p&gt;</summary>
    
    
    
    <category term="深入浅出 React" scheme="https://kerita.me/categories/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA-React/"/>
    
    
  </entry>
  
  <entry>
    <title>React 生命周期</title>
    <link href="https://kerita.me/07/26/dive-in-react/2-lifecycle/"/>
    <id>https://kerita.me/07/26/dive-in-react/2-lifecycle/</id>
    <published>2021-07-26T00:00:00.000Z</published>
    <updated>2021-08-01T13:18:48.597Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;React-生命周期&quot;&gt;&lt;a href=&quot;#React-生命周期&quot; class=&quot;headerlink&quot; title=&quot;React 生命周期&quot;&gt;&lt;/a&gt;React 生命周期&lt;/h2&gt;&lt;p&gt;React 是一个构建用户界面的 JavaScript 库，其核心的 Virtual DOM 是由生命周期的 render 方法生成的。初始化时，render 方法生成 Virtual DOM 交给 ReactDOM.render 方法渲染成真实 DOM；更新时， render 方法生成的新 Virtual DOM 与旧 Virtual DOM 进行比较，针对差异部分 ReactDOM.render 对真实 DOM 进行修改。&lt;/p&gt;
&lt;p&gt;React 生命周期中的 render 在其中扮演着 Virtual DOM 生成的关键角色，其他生命周期则像是 render 方法的辅助，做数据的初始化或者修改，辅助 render 方法完成 Virtual DOM 的生成。&lt;/p&gt;</summary>
    
    
    
    <category term="深入浅出 React" scheme="https://kerita.me/categories/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA-React/"/>
    
    
  </entry>
  
  <entry>
    <title>React 组件之间数据传递</title>
    <link href="https://kerita.me/07/26/dive-in-react/4-data/"/>
    <id>https://kerita.me/07/26/dive-in-react/4-data/</id>
    <published>2021-07-26T00:00:00.000Z</published>
    <updated>2021-08-01T13:18:48.601Z</updated>
    
    
    <summary type="html">&lt;p&gt;React 是一个构建用户界面的 JavaScript 库，其思想是用数据驱动视图。&lt;/p&gt;
&lt;p&gt;可以用如下代码来表示：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;UI &amp;#x3D; render(data)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;data 就是 React 界面的核心。在渲染用户界面时，data 不是静止不动的，它可能需要在父子组件之间共享、可能需要在兄弟组件共享以及其他层次关系的组件之间共享。下面我们就讲 4 种组件间数据传递的方式。&lt;/p&gt;</summary>
    
    
    
    <category term="深入浅出 React" scheme="https://kerita.me/categories/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA-React/"/>
    
    
  </entry>
  
  <entry>
    <title>什么是函数式编程</title>
    <link href="https://kerita.me/07/25/2021/func/"/>
    <id>https://kerita.me/07/25/2021/func/</id>
    <published>2021-07-25T00:00:00.000Z</published>
    <updated>2021-08-01T13:18:48.593Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;什么是函数式编程&quot;&gt;&lt;a href=&quot;#什么是函数式编程&quot; class=&quot;headerlink&quot; title=&quot;什么是函数式编程&quot;&gt;&lt;/a&gt;什么是函数式编程&lt;/h2&gt;&lt;p&gt;函数式编程是一种编程范式。编程范式是基于程序语言的特点对程序语言进行分类的一种方式，常见的编程范式有：函数式编程、指令式编程、过程式编程、面向对象编程等等。&lt;/p&gt;
&lt;p&gt;在面向对象编程中，程序则是一系列相互作用的对象，由于方法论的不同，面向对象编程范式又分为基于类编程和基于原型编程。&lt;/p&gt;
&lt;p&gt;函数式编程的理论基础 Lambda 演算。Lambda 演算是一种数学的抽象，是研究函数如何抽象定义、函数如何被引用以及递归的形式系统。一个函数式编程程序会被看作是一个无状态的函数计算的序列，正如函数关心的是数据的映射，函数式编程也是如此。&lt;/p&gt;</summary>
    
    
    
    <category term="React" scheme="https://kerita.me/categories/React/"/>
    
    
  </entry>
  
  <entry>
    <title>什么是 JSX</title>
    <link href="https://kerita.me/07/23/dive-in-react/1-jsx/"/>
    <id>https://kerita.me/07/23/dive-in-react/1-jsx/</id>
    <published>2021-07-23T00:00:00.000Z</published>
    <updated>2021-08-01T13:18:48.597Z</updated>
    
    
    <summary type="html">&lt;p&gt;在使用 React 开发项目的过程，我们都会使用 JSX 来描述 UI。今天我们就来聊聊什么是 JSX。&lt;/p&gt;</summary>
    
    
    
    <category term="深入浅出 React" scheme="https://kerita.me/categories/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA-React/"/>
    
    
  </entry>
  
  <entry>
    <title>React 和 Vue 有什么异同</title>
    <link href="https://kerita.me/07/21/fe-attack/16-react-vs-vue/"/>
    <id>https://kerita.me/07/21/fe-attack/16-react-vs-vue/</id>
    <published>2021-07-21T00:00:00.000Z</published>
    <updated>2021-08-01T13:18:48.621Z</updated>
    
    
    <summary type="html">&lt;p&gt;React 和 Vue 是当下最流行的两大前端框架，今天我们来对比下他们有什么异同。&lt;/p&gt;</summary>
    
    
    
    <category term="前端进击笔记" scheme="https://kerita.me/categories/%E5%89%8D%E7%AB%AF%E8%BF%9B%E5%87%BB%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>前端组件化和模块化</title>
    <link href="https://kerita.me/07/20/fe-attack/14-design/"/>
    <id>https://kerita.me/07/20/fe-attack/14-design/</id>
    <published>2021-07-20T00:00:00.000Z</published>
    <updated>2021-08-01T13:18:48.621Z</updated>
    
    
    <summary type="html">&lt;p&gt;前端有两个大方向一定要掌握，一是组件化和模块化，二是工程化，今天我们来聊一聊组件化和模块化。组件化和模块化满足了软件工程低内聚、高耦合、代码模块化的原则，提高代码的可重用性和可复用性，是提高工作效率的重要法宝。&lt;/p&gt;</summary>
    
    
    
    <category term="前端进击笔记" scheme="https://kerita.me/categories/%E5%89%8D%E7%AB%AF%E8%BF%9B%E5%87%BB%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>单页应用与前端路由库设计原理</title>
    <link href="https://kerita.me/07/18/fe-attack/12-spa/"/>
    <id>https://kerita.me/07/18/fe-attack/12-spa/</id>
    <published>2021-07-18T00:00:00.000Z</published>
    <updated>2021-08-01T13:18:48.621Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;什么是单页应用&quot;&gt;&lt;a href=&quot;#什么是单页应用&quot; class=&quot;headerlink&quot; title=&quot;什么是单页应用&quot;&gt;&lt;/a&gt;什么是单页应用&lt;/h2&gt;&lt;p&gt;单页应用就是只有一个 HTML 页面的应用，页面 URL 的变化只是通过浏览器 API 修改，浏览器不会向服务器请求新的 HTML 的，而是通过 JS 控制不同的 URL 渲染相应的内容。&lt;/p&gt;
&lt;p&gt;单页应用相比传统的 JSP、PHP 多页应用，在切换页面时无需刷新，只需进行局部更新，加载内容快，页面的数据状态和用户数据依然保留。但是，因为单页应用返回的是一个 body 空白的 HTML 文件，HTML 内容由 JS 生成，搜索引擎无法获取到，可能影响搜索引擎排名。&lt;/p&gt;</summary>
    
    
    
    <category term="前端进击笔记" scheme="https://kerita.me/categories/%E5%89%8D%E7%AB%AF%E8%BF%9B%E5%87%BB%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>前端模块标准和 Webpack 工作流程</title>
    <link href="https://kerita.me/07/18/fe-attack/13-module/"/>
    <id>https://kerita.me/07/18/fe-attack/13-module/</id>
    <published>2021-07-18T00:00:00.000Z</published>
    <updated>2021-08-01T13:18:48.621Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;CommonJS-与-ES6-Module-的区别&quot;&gt;&lt;a href=&quot;#CommonJS-与-ES6-Module-的区别&quot; class=&quot;headerlink&quot; title=&quot;CommonJS 与 ES6 Module 的区别&quot;&gt;&lt;/a&gt;CommonJS 与 ES6 Module 的区别&lt;/h2&gt;&lt;p&gt;可以参考本博客之前的文章 &lt;a href=&quot;/04/03/2021/module/&quot;&gt;CommonJS 与 ES6 Module 的区别&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="前端进击笔记" scheme="https://kerita.me/categories/%E5%89%8D%E7%AB%AF%E8%BF%9B%E5%87%BB%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>几种常见的大前端应用</title>
    <link href="https://kerita.me/07/16/fe-attack/11-fe/"/>
    <id>https://kerita.me/07/16/fe-attack/11-fe/</id>
    <published>2021-07-16T00:00:00.000Z</published>
    <updated>2021-08-01T13:18:48.617Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;什么是-Hybrid-App&quot;&gt;&lt;a href=&quot;#什么是-Hybrid-App&quot; class=&quot;headerlink&quot; title=&quot;什么是 Hybrid App&quot;&gt;&lt;/a&gt;什么是 Hybrid App&lt;/h2&gt;&lt;p&gt;Hybrid App 是融合了 Native App 和 Web App 的混合 App，Web App 运行在 Native App 提供的 WebView 中，Web App 通过中间的 bridge 调用 Native 的功能。传统的 Hybrid App 开发技术有 Cordova，Phone Gap 和 Ionic。&lt;/p&gt;</summary>
    
    
    
    <category term="前端进击笔记" scheme="https://kerita.me/categories/%E5%89%8D%E7%AB%AF%E8%BF%9B%E5%87%BB%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>前端框架模板引擎的实现原理</title>
    <link href="https://kerita.me/07/15/fe-attack/10-framework/"/>
    <id>https://kerita.me/07/15/fe-attack/10-framework/</id>
    <published>2021-07-15T00:00:00.000Z</published>
    <updated>2021-08-01T13:18:48.617Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;Vue-模板引擎工作过程&quot;&gt;&lt;a href=&quot;#Vue-模板引擎工作过程&quot; class=&quot;headerlink&quot; title=&quot;Vue 模板引擎工作过程&quot;&gt;&lt;/a&gt;Vue 模板引擎工作过程&lt;/h2&gt;&lt;p&gt;以 Vue 为例子，对于开发者编写的 Vue 代码，Vue 会将其进行以下处理从而渲染到页面中：&lt;/p&gt;
&lt;p&gt;1.解析语法生成 AST 对象；&lt;/p&gt;
&lt;p&gt;2.根据生成的 AST 对象，完成 data 数据初始化；&lt;/p&gt;
&lt;p&gt;3.根据 AST 对象和 data 数据绑定情况，生成虚拟 DOM 对象；&lt;/p&gt;
&lt;p&gt;4.将虚拟 DOM 对象生成真正的 DOM 元素插入到页面中，此时页面会被渲染。&lt;/p&gt;</summary>
    
    
    
    <category term="前端进击笔记" scheme="https://kerita.me/categories/%E5%89%8D%E7%AB%AF%E8%BF%9B%E5%87%BB%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="浏览器" scheme="https://kerita.me/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>浏览器是如何渲染的</title>
    <link href="https://kerita.me/07/13/fe-attack/8-render/"/>
    <id>https://kerita.me/07/13/fe-attack/8-render/</id>
    <published>2021-07-13T00:00:00.000Z</published>
    <updated>2021-08-01T13:18:48.641Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;渲染过程&quot;&gt;&lt;a href=&quot;#渲染过程&quot; class=&quot;headerlink&quot; title=&quot;渲染过程&quot;&gt;&lt;/a&gt;渲染过程&lt;/h2&gt;&lt;p&gt;1.解析 HTML 文件，创建 DOM 树&lt;br&gt;浏览器解析 html 源码，然后创建一个 DOM 树。并行请求 css/image/js 在 DOM 树中，每一个 HTML 标签都有一个对应的节点，并且每一个文本也都会有一个对应的文本节点。DOM 树的根节点就是 documentElement，对应的是 html 标签。&lt;/p&gt;
&lt;p&gt;2.解析 CSS,形成 CSS 对象模型&lt;br&gt;浏览器解析 CSS 代码，计算出最终的样式数据。构建 CSSOM 树。对 CSS 代码中非法的语法它会直接忽略掉。解析 CSS 的时候会按照如下顺序来定义优先级：&lt;br&gt;浏览器默认设置 &amp;lt; 用户设置 &amp;lt; 外链样式 &amp;lt; 内联样式 &amp;lt; html 中的 style。&lt;/p&gt;
&lt;p&gt;3.将 CSS 与 DOM 合并，构建渲染树（renderingtree）&lt;br&gt;DOM Tree + CSSOM –&amp;gt; 渲染树（rendering tree）。渲染树和 DOM 树有点像，但是是有区别的。DOM 树完全和 html 标签一一对应，但是渲染树会忽略掉不需要渲染的元素，比如 head、display:none 的元素等。而且一大段文本中的每一个行在渲染树中都是独立的一个节点。渲染树中的每一个节点都存储有对应的 css 属性。&lt;/p&gt;</summary>
    
    
    
    <category term="前端进击笔记" scheme="https://kerita.me/categories/%E5%89%8D%E7%AB%AF%E8%BF%9B%E5%87%BB%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="浏览器" scheme="https://kerita.me/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>什么是 HTTP 协议</title>
    <link href="https://kerita.me/07/12/fe-attack/7-http/"/>
    <id>https://kerita.me/07/12/fe-attack/7-http/</id>
    <published>2021-07-12T00:00:00.000Z</published>
    <updated>2021-08-01T13:18:48.633Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;什么是-RESTful-接口&quot;&gt;&lt;a href=&quot;#什么是-RESTful-接口&quot; class=&quot;headerlink&quot; title=&quot;什么是 RESTful 接口&quot;&gt;&lt;/a&gt;什么是 RESTful 接口&lt;/h2&gt;&lt;p&gt;RESTful 不是一种协议，而是一种接口设计风格，其要点如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;URL 只有名词&lt;/li&gt;
&lt;li&gt;看 URL 就知道是什么业务&lt;/li&gt;
&lt;li&gt;看 method 就知道是什么操作&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;GET &amp;#x2F;orders&amp;#x2F;1234	&amp;#x2F;&amp;#x2F; 查询订单&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;POST &amp;#x2F;orders&amp;#x2F;1234	&amp;#x2F;&amp;#x2F; 新增订单&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;PUT &amp;#x2F;orders&amp;#x2F;1234	&amp;#x2F;&amp;#x2F; 修改订单&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;DELETE &amp;#x2F;orders&amp;#x2F;1234	&amp;#x2F;&amp;#x2F; 删除订单&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="前端进击笔记" scheme="https://kerita.me/categories/%E5%89%8D%E7%AB%AF%E8%BF%9B%E5%87%BB%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="HTTP" scheme="https://kerita.me/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>接口对接 SOP —及时沟通与前置风险</title>
    <link href="https://kerita.me/07/08/2021/api/"/>
    <id>https://kerita.me/07/08/2021/api/</id>
    <published>2021-07-08T00:00:00.000Z</published>
    <updated>2021-08-01T13:18:48.585Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;接口对接过程遇到的问题&quot;&gt;&lt;a href=&quot;#接口对接过程遇到的问题&quot; class=&quot;headerlink&quot; title=&quot;接口对接过程遇到的问题&quot;&gt;&lt;/a&gt;接口对接过程遇到的问题&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;没有接口文档，接口口头或者企业微信简单确认（特别是只有一两个接口）&lt;/li&gt;
&lt;li&gt;接口文档没有确定交付时间，或者到时间没有交付&lt;/li&gt;
&lt;li&gt;接口文档不全，部分接口缺失或者接口部分字段缺失&lt;/li&gt;
&lt;li&gt;后端修改接口没有通知前端，导致实际接口与接口文档不一致&lt;/li&gt;
&lt;li&gt;……&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="前端" scheme="https://kerita.me/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="项目" scheme="https://kerita.me/tags/%E9%A1%B9%E7%9B%AE/"/>
    
  </entry>
  
  <entry>
    <title>浏览器如何进行网络请求</title>
    <link href="https://kerita.me/07/06/fe-attack/6-request/"/>
    <id>https://kerita.me/07/06/fe-attack/6-request/</id>
    <published>2021-07-06T00:00:00.000Z</published>
    <updated>2021-08-01T13:18:48.629Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;输入一个-URL-敲下回车键发生了什么&quot;&gt;&lt;a href=&quot;#输入一个-URL-敲下回车键发生了什么&quot; class=&quot;headerlink&quot; title=&quot;输入一个 URL 敲下回车键发生了什么&quot;&gt;&lt;/a&gt;输入一个 URL 敲下回车键发生了什么&lt;/h2&gt;&lt;p&gt;1.DNS 域名解析（此处涉及 DNS 的寻址过程），找到网页的存放服务器；&lt;/p&gt;
&lt;p&gt;2.浏览器与服务器建立 TCP 连接；&lt;/p&gt;
&lt;p&gt;3.浏览器发起 HTTP 请求；&lt;/p&gt;
&lt;p&gt;4.服务器响应 HTTP 请求，返回该页面的 HTML 内容；&lt;/p&gt;
&lt;p&gt;5.浏览器解析 HTML 代码，并请求 HTML 代码中的资源（如 JavaScript、CSS、图片等，此处可能涉及 HTTP 缓存）；&lt;/p&gt;
&lt;p&gt;6.浏览器对页面进行渲染呈现给用户（此处涉及浏览器的渲染原理）。&lt;/p&gt;</summary>
    
    
    
    <category term="前端进击笔记" scheme="https://kerita.me/categories/%E5%89%8D%E7%AB%AF%E8%BF%9B%E5%87%BB%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Ajax" scheme="https://kerita.me/tags/Ajax/"/>
    
  </entry>
  
</feed>
