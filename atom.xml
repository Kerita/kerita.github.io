<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Kerita</title>
  <icon>https://kerita.me/icon.webp</icon>
  <subtitle>自律谦逊，承担责任，推迟满足感，你要热爱它</subtitle>
  <link href="https://kerita.me/atom.xml" rel="self"/>
  
  <link href="https://kerita.me/"/>
  <updated>2021-07-26T11:43:44.476Z</updated>
  <id>https://kerita.me/</id>
  
  <author>
    <name>Kerita</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>React 生命周期</title>
    <link href="https://kerita.me/07/26/dive-in-react/2-lifecycle/"/>
    <id>https://kerita.me/07/26/dive-in-react/2-lifecycle/</id>
    <published>2021-07-26T00:00:00.000Z</published>
    <updated>2021-07-26T11:43:44.476Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;React-生命周期&quot;&gt;&lt;a href=&quot;#React-生命周期&quot; class=&quot;headerlink&quot; title=&quot;React 生命周期&quot;&gt;&lt;/a&gt;React 生命周期&lt;/h2&gt;&lt;p&gt;React 是一个构建用户界面的 JavaScript 库，其核心的 Virtual DOM 是由生命周期的 render 方法生成的。初始化时，render 方法生成 Virtual DOM 交给 ReactDOM.render 方法渲染成真实 DOM；更新时， render 方法生成的新 Virtual DOM 与旧 Virtual DOM 进行比较，针对差异部分 ReactDOM.render 对真实 DOM 进行修改。&lt;/p&gt;
&lt;p&gt;React 生命周期中的 render 在其中扮演着 Virtual DOM 生成的关键角色，其他生命周期则像是 render 方法的辅助，做数据的初始化或者修改，辅助 render 方法完成 Virtual DOM 的生成。&lt;/p&gt;</summary>
    
    
    
    <category term="深入浅出 React" scheme="https://kerita.me/categories/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA-React/"/>
    
    
  </entry>
  
  <entry>
    <title>什么是函数式编程</title>
    <link href="https://kerita.me/07/25/2021/func/"/>
    <id>https://kerita.me/07/25/2021/func/</id>
    <published>2021-07-25T00:00:00.000Z</published>
    <updated>2021-07-26T11:43:44.476Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;什么是函数式编程&quot;&gt;&lt;a href=&quot;#什么是函数式编程&quot; class=&quot;headerlink&quot; title=&quot;什么是函数式编程&quot;&gt;&lt;/a&gt;什么是函数式编程&lt;/h2&gt;&lt;p&gt;函数式编程是一种编程范式。编程范式是基于程序语言的特点对程序语言进行分类的一种方式，常见的编程范式有：函数式编程、指令式编程、过程式编程、面向对象编程等等。&lt;/p&gt;
&lt;p&gt;在面向对象编程中，程序则是一系列相互作用的对象，由于方法论的不同，面向对象编程范式又分为基于类编程和基于原型编程。&lt;/p&gt;
&lt;p&gt;函数式编程的理论基础 Lambda 演算。Lambda 演算是一种数学的抽象，是研究函数如何抽象定义、函数如何被引用以及递归的形式系统。一个函数式编程程序会被看作是一个无状态的函数计算的序列，正如函数关心的是数据的映射，函数式编程也是如此。&lt;/p&gt;</summary>
    
    
    
    <category term="React" scheme="https://kerita.me/categories/React/"/>
    
    
  </entry>
  
  <entry>
    <title>什么是 JSX</title>
    <link href="https://kerita.me/07/23/dive-in-react/1-jsx/"/>
    <id>https://kerita.me/07/23/dive-in-react/1-jsx/</id>
    <published>2021-07-23T00:00:00.000Z</published>
    <updated>2021-07-26T11:43:44.476Z</updated>
    
    
    <summary type="html">&lt;p&gt;在使用 React 开发项目的过程，我们都会使用 JSX 来描述 UI。今天我们就来聊聊什么是 JSX。&lt;/p&gt;</summary>
    
    
    
    <category term="深入浅出 React" scheme="https://kerita.me/categories/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA-React/"/>
    
    
  </entry>
  
  <entry>
    <title>React 和 Vue 有什么异同</title>
    <link href="https://kerita.me/07/21/fe-attack/16-react-vs-vue/"/>
    <id>https://kerita.me/07/21/fe-attack/16-react-vs-vue/</id>
    <published>2021-07-21T00:00:00.000Z</published>
    <updated>2021-07-26T11:43:44.500Z</updated>
    
    
    <summary type="html">&lt;p&gt;React 和 Vue 是当下最流行的两大前端框架，今天我们来对比下他们有什么异同。&lt;/p&gt;</summary>
    
    
    
    <category term="前端进击笔记" scheme="https://kerita.me/categories/%E5%89%8D%E7%AB%AF%E8%BF%9B%E5%87%BB%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>前端组件化和模块化</title>
    <link href="https://kerita.me/07/20/fe-attack/14-design/"/>
    <id>https://kerita.me/07/20/fe-attack/14-design/</id>
    <published>2021-07-20T00:00:00.000Z</published>
    <updated>2021-07-26T11:43:44.500Z</updated>
    
    
    <summary type="html">&lt;p&gt;前端有两个大方向一定要掌握，一是组件化和模块化，二是工程化，今天我们来聊一聊组件化和模块化。组件化和模块化满足了软件工程低内聚、高耦合、代码模块化的原则，提高代码的可重用性和可复用性，是提高工作效率的重要法宝。&lt;/p&gt;</summary>
    
    
    
    <category term="前端进击笔记" scheme="https://kerita.me/categories/%E5%89%8D%E7%AB%AF%E8%BF%9B%E5%87%BB%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>单页应用与前端路由库设计原理</title>
    <link href="https://kerita.me/07/18/fe-attack/12-spa/"/>
    <id>https://kerita.me/07/18/fe-attack/12-spa/</id>
    <published>2021-07-18T00:00:00.000Z</published>
    <updated>2021-07-26T11:43:44.500Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;什么是单页应用&quot;&gt;&lt;a href=&quot;#什么是单页应用&quot; class=&quot;headerlink&quot; title=&quot;什么是单页应用&quot;&gt;&lt;/a&gt;什么是单页应用&lt;/h2&gt;&lt;p&gt;单页应用就是只有一个 HTML 页面的应用，页面 URL 的变化只是通过浏览器 API 修改，浏览器不会向服务器请求新的 HTML 的，而是通过 JS 控制不同的 URL 渲染相应的内容。&lt;/p&gt;
&lt;p&gt;单页应用相比传统的 JSP、PHP 多页应用，在切换页面时无需刷新，只需进行局部更新，加载内容快，页面的数据状态和用户数据依然保留。但是，因为单页应用返回的是一个 body 空白的 HTML 文件，HTML 内容由 JS 生成，搜索引擎无法获取到，可能影响搜索引擎排名。&lt;/p&gt;</summary>
    
    
    
    <category term="前端进击笔记" scheme="https://kerita.me/categories/%E5%89%8D%E7%AB%AF%E8%BF%9B%E5%87%BB%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>前端模块标准和 Webpack 工作流程</title>
    <link href="https://kerita.me/07/18/fe-attack/13-module/"/>
    <id>https://kerita.me/07/18/fe-attack/13-module/</id>
    <published>2021-07-18T00:00:00.000Z</published>
    <updated>2021-07-26T11:43:44.500Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;CommonJS-与-ES6-Module-的区别&quot;&gt;&lt;a href=&quot;#CommonJS-与-ES6-Module-的区别&quot; class=&quot;headerlink&quot; title=&quot;CommonJS 与 ES6 Module 的区别&quot;&gt;&lt;/a&gt;CommonJS 与 ES6 Module 的区别&lt;/h2&gt;&lt;p&gt;可以参考本博客之前的文章 &lt;a href=&quot;/04/03/2021/module/&quot;&gt;CommonJS 与 ES6 Module 的区别&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="前端进击笔记" scheme="https://kerita.me/categories/%E5%89%8D%E7%AB%AF%E8%BF%9B%E5%87%BB%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>几种常见的大前端应用</title>
    <link href="https://kerita.me/07/16/fe-attack/11-fe/"/>
    <id>https://kerita.me/07/16/fe-attack/11-fe/</id>
    <published>2021-07-16T00:00:00.000Z</published>
    <updated>2021-07-26T11:43:44.496Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;什么是-Hybrid-App&quot;&gt;&lt;a href=&quot;#什么是-Hybrid-App&quot; class=&quot;headerlink&quot; title=&quot;什么是 Hybrid App&quot;&gt;&lt;/a&gt;什么是 Hybrid App&lt;/h2&gt;&lt;p&gt;Hybrid App 是融合了 Native App 和 Web App 的混合 App，Web App 运行在 Native App 提供的 WebView 中，Web App 通过中间的 bridge 调用 Native 的功能。传统的 Hybrid App 开发技术有 Cordova，Phone Gap 和 Ionic。&lt;/p&gt;</summary>
    
    
    
    <category term="前端进击笔记" scheme="https://kerita.me/categories/%E5%89%8D%E7%AB%AF%E8%BF%9B%E5%87%BB%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>前端框架模板引擎的实现原理</title>
    <link href="https://kerita.me/07/15/fe-attack/10-framework/"/>
    <id>https://kerita.me/07/15/fe-attack/10-framework/</id>
    <published>2021-07-15T00:00:00.000Z</published>
    <updated>2021-07-26T11:43:44.496Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;Vue-模板引擎工作过程&quot;&gt;&lt;a href=&quot;#Vue-模板引擎工作过程&quot; class=&quot;headerlink&quot; title=&quot;Vue 模板引擎工作过程&quot;&gt;&lt;/a&gt;Vue 模板引擎工作过程&lt;/h2&gt;&lt;p&gt;以 Vue 为例子，对于开发者编写的 Vue 代码，Vue 会将其进行以下处理从而渲染到页面中：&lt;/p&gt;
&lt;p&gt;1.解析语法生成 AST 对象；&lt;/p&gt;
&lt;p&gt;2.根据生成的 AST 对象，完成 data 数据初始化；&lt;/p&gt;
&lt;p&gt;3.根据 AST 对象和 data 数据绑定情况，生成虚拟 DOM 对象；&lt;/p&gt;
&lt;p&gt;4.将虚拟 DOM 对象生成真正的 DOM 元素插入到页面中，此时页面会被渲染。&lt;/p&gt;</summary>
    
    
    
    <category term="前端进击笔记" scheme="https://kerita.me/categories/%E5%89%8D%E7%AB%AF%E8%BF%9B%E5%87%BB%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="浏览器" scheme="https://kerita.me/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>浏览器是如何渲染的</title>
    <link href="https://kerita.me/07/13/fe-attack/8-render/"/>
    <id>https://kerita.me/07/13/fe-attack/8-render/</id>
    <published>2021-07-13T00:00:00.000Z</published>
    <updated>2021-07-26T11:43:44.520Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;渲染过程&quot;&gt;&lt;a href=&quot;#渲染过程&quot; class=&quot;headerlink&quot; title=&quot;渲染过程&quot;&gt;&lt;/a&gt;渲染过程&lt;/h2&gt;&lt;p&gt;1.解析 HTML 文件，创建 DOM 树&lt;br&gt;浏览器解析 html 源码，然后创建一个 DOM 树。并行请求 css/image/js 在 DOM 树中，每一个 HTML 标签都有一个对应的节点，并且每一个文本也都会有一个对应的文本节点。DOM 树的根节点就是 documentElement，对应的是 html 标签。&lt;/p&gt;
&lt;p&gt;2.解析 CSS,形成 CSS 对象模型&lt;br&gt;浏览器解析 CSS 代码，计算出最终的样式数据。构建 CSSOM 树。对 CSS 代码中非法的语法它会直接忽略掉。解析 CSS 的时候会按照如下顺序来定义优先级：&lt;br&gt;浏览器默认设置 &amp;lt; 用户设置 &amp;lt; 外链样式 &amp;lt; 内联样式 &amp;lt; html 中的 style。&lt;/p&gt;
&lt;p&gt;3.将 CSS 与 DOM 合并，构建渲染树（renderingtree）&lt;br&gt;DOM Tree + CSSOM –&amp;gt; 渲染树（rendering tree）。渲染树和 DOM 树有点像，但是是有区别的。DOM 树完全和 html 标签一一对应，但是渲染树会忽略掉不需要渲染的元素，比如 head、display:none 的元素等。而且一大段文本中的每一个行在渲染树中都是独立的一个节点。渲染树中的每一个节点都存储有对应的 css 属性。&lt;/p&gt;</summary>
    
    
    
    <category term="前端进击笔记" scheme="https://kerita.me/categories/%E5%89%8D%E7%AB%AF%E8%BF%9B%E5%87%BB%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="浏览器" scheme="https://kerita.me/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>什么是 HTTP 协议</title>
    <link href="https://kerita.me/07/12/fe-attack/7-http/"/>
    <id>https://kerita.me/07/12/fe-attack/7-http/</id>
    <published>2021-07-12T00:00:00.000Z</published>
    <updated>2021-07-26T11:43:44.512Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;什么是-RESTful-接口&quot;&gt;&lt;a href=&quot;#什么是-RESTful-接口&quot; class=&quot;headerlink&quot; title=&quot;什么是 RESTful 接口&quot;&gt;&lt;/a&gt;什么是 RESTful 接口&lt;/h2&gt;&lt;p&gt;RESTful 不是一种协议，而是一种接口设计风格，其要点如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;URL 只有名词&lt;/li&gt;
&lt;li&gt;看 URL 就知道是什么业务&lt;/li&gt;
&lt;li&gt;看 method 就知道是什么操作&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;GET &amp;#x2F;orders&amp;#x2F;1234	&amp;#x2F;&amp;#x2F; 查询订单&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;POST &amp;#x2F;orders&amp;#x2F;1234	&amp;#x2F;&amp;#x2F; 新增订单&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;PUT &amp;#x2F;orders&amp;#x2F;1234	&amp;#x2F;&amp;#x2F; 修改订单&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;DELETE &amp;#x2F;orders&amp;#x2F;1234	&amp;#x2F;&amp;#x2F; 删除订单&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="前端进击笔记" scheme="https://kerita.me/categories/%E5%89%8D%E7%AB%AF%E8%BF%9B%E5%87%BB%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="HTTP" scheme="https://kerita.me/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>接口对接 SOP —及时沟通与前置风险</title>
    <link href="https://kerita.me/07/08/2021/api/"/>
    <id>https://kerita.me/07/08/2021/api/</id>
    <published>2021-07-08T00:00:00.000Z</published>
    <updated>2021-07-26T11:43:44.468Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;接口对接过程遇到的问题&quot;&gt;&lt;a href=&quot;#接口对接过程遇到的问题&quot; class=&quot;headerlink&quot; title=&quot;接口对接过程遇到的问题&quot;&gt;&lt;/a&gt;接口对接过程遇到的问题&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;没有接口文档，接口口头或者企业微信简单确认（特别是只有一两个接口）&lt;/li&gt;
&lt;li&gt;接口文档没有确定交付时间，或者到时间没有交付&lt;/li&gt;
&lt;li&gt;接口文档不全，部分接口缺失或者接口部分字段缺失&lt;/li&gt;
&lt;li&gt;后端修改接口没有通知前端，导致实际接口与接口文档不一致&lt;/li&gt;
&lt;li&gt;……&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="前端" scheme="https://kerita.me/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="项目" scheme="https://kerita.me/tags/%E9%A1%B9%E7%9B%AE/"/>
    
  </entry>
  
  <entry>
    <title>浏览器如何进行网络请求</title>
    <link href="https://kerita.me/07/06/fe-attack/6-request/"/>
    <id>https://kerita.me/07/06/fe-attack/6-request/</id>
    <published>2021-07-06T00:00:00.000Z</published>
    <updated>2021-07-26T11:43:44.508Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;输入一个-URL-敲下回车键发生了什么&quot;&gt;&lt;a href=&quot;#输入一个-URL-敲下回车键发生了什么&quot; class=&quot;headerlink&quot; title=&quot;输入一个 URL 敲下回车键发生了什么&quot;&gt;&lt;/a&gt;输入一个 URL 敲下回车键发生了什么&lt;/h2&gt;&lt;p&gt;1.DNS 域名解析（此处涉及 DNS 的寻址过程），找到网页的存放服务器；&lt;/p&gt;
&lt;p&gt;2.浏览器与服务器建立 TCP 连接；&lt;/p&gt;
&lt;p&gt;3.浏览器发起 HTTP 请求；&lt;/p&gt;
&lt;p&gt;4.服务器响应 HTTP 请求，返回该页面的 HTML 内容；&lt;/p&gt;
&lt;p&gt;5.浏览器解析 HTML 代码，并请求 HTML 代码中的资源（如 JavaScript、CSS、图片等，此处可能涉及 HTTP 缓存）；&lt;/p&gt;
&lt;p&gt;6.浏览器对页面进行渲染呈现给用户（此处涉及浏览器的渲染原理）。&lt;/p&gt;</summary>
    
    
    
    <category term="前端进击笔记" scheme="https://kerita.me/categories/%E5%89%8D%E7%AB%AF%E8%BF%9B%E5%87%BB%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Ajax" scheme="https://kerita.me/tags/Ajax/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 的运行机制</title>
    <link href="https://kerita.me/07/05/fe-attack/5-js-run/"/>
    <id>https://kerita.me/07/05/fe-attack/5-js-run/</id>
    <published>2021-07-05T00:00:00.000Z</published>
    <updated>2021-07-26T11:43:44.504Z</updated>
    
    
    <summary type="html">&lt;p&gt;JavaScript 作为是一门单线程语言，使用事件循环(Event Loop)机制，来执行代码和收集回调队列的子任务。&lt;/p&gt;</summary>
    
    
    
    <category term="前端进击笔记" scheme="https://kerita.me/categories/%E5%89%8D%E7%AB%AF%E8%BF%9B%E5%87%BB%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="JS" scheme="https://kerita.me/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 实现继承</title>
    <link href="https://kerita.me/06/30/fe-attack/4-js/"/>
    <id>https://kerita.me/06/30/fe-attack/4-js/</id>
    <published>2021-06-30T00:00:00.000Z</published>
    <updated>2021-07-26T11:43:44.504Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;JavaScript 的函数怎么也是个对象？&lt;br&gt;1.JavaScript 中除了基本类型，其他都是对象，Symbol 也是基本数据类型。&lt;br&gt;2.函数是一种特殊的对象，它也拥有属性和值，有一个特别的属性 prototype，该属性就是函数的原型对象。&lt;br&gt;3.函数的原型对象(prototype) 都拥有 constructor 属性，该属性指向与之关联的构造函数。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;__proto__&lt;/code&gt; 和 prototype 到底是啥关系？&lt;br&gt;1.每个对象都有 &lt;code&gt;__proto__&lt;/code&gt; 属性来标识自己所继承的原型对象，但只有函数才有 prototype 属性。&lt;br&gt;2.每个函数都有一个 prototype 属性，该属性为函数的原型对象。&lt;br&gt;3.通过将实例对象的 &lt;code&gt;__proto__&lt;/code&gt; 属性赋值为其构造函数的原型对象 prototype，JavaScript 可以使用构造函数创建对象的方法，来实现继承。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;JavaScript 中对象是怎么实现继承的？&lt;br&gt;通过原型链访问对象的方法和属性，找到返回对应的值，直到访问 &lt;code&gt;Object.prototype&lt;/code&gt; 的原型对象 null 仍没找到的，返回 undefined。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;JavaScript 是怎么访问对象的方法和属性的？&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="前端进击笔记" scheme="https://kerita.me/categories/%E5%89%8D%E7%AB%AF%E8%BF%9B%E5%87%BB%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="JS" scheme="https://kerita.me/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>CSS 知识点</title>
    <link href="https://kerita.me/06/28/fe-attack/3-css/"/>
    <id>https://kerita.me/06/28/fe-attack/3-css/</id>
    <published>2021-06-28T00:00:00.000Z</published>
    <updated>2021-07-26T11:43:44.500Z</updated>
    
    
    <summary type="html">&lt;p&gt;记录 CSS 重要知识点。&lt;/p&gt;</summary>
    
    
    
    <category term="前端进击笔记" scheme="https://kerita.me/categories/%E5%89%8D%E7%AB%AF%E8%BF%9B%E5%87%BB%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="CSS" scheme="https://kerita.me/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>HTML 加载过程</title>
    <link href="https://kerita.me/06/27/fe-attack/2-html/"/>
    <id>https://kerita.me/06/27/fe-attack/2-html/</id>
    <published>2021-06-27T00:00:00.000Z</published>
    <updated>2021-07-26T11:43:44.500Z</updated>
    
    
    <summary type="html">&lt;p&gt;浏览器在加载页面的过程会用到 GUI 渲染线程和 JavaScript 引擎线程，其中 GUI 渲染线程负责 HTML，JavaScript 引擎线程负责执行 JavaScript 脚本。&lt;/p&gt;</summary>
    
    
    
    <category term="前端进击笔记" scheme="https://kerita.me/categories/%E5%89%8D%E7%AB%AF%E8%BF%9B%E5%87%BB%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="HTML" scheme="https://kerita.me/tags/HTML/"/>
    
  </entry>
  
  <entry>
    <title>什么是 Babel？</title>
    <link href="https://kerita.me/06/24/2021/babel/"/>
    <id>https://kerita.me/06/24/2021/babel/</id>
    <published>2021-06-24T00:00:00.000Z</published>
    <updated>2021-07-26T11:43:44.468Z</updated>
    
    
    <summary type="html">&lt;p&gt;Babel 对自己的定位：下一代 JavaScript 的编译器。它将新语法、新 API 编译成兼容代码，以便在老版本的浏览器也能使用。&lt;/p&gt;
&lt;p&gt;Babel 基于插件架构，如果什么插件都不提供，babel 也不做什么事情，其作用如下。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;const babel &amp;#x3D; code &amp;#x3D;&amp;gt; code&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="前端" scheme="https://kerita.me/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="工程化" scheme="https://kerita.me/tags/%E5%B7%A5%E7%A8%8B%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>前端知识体系</title>
    <link href="https://kerita.me/06/24/fe-attack/1-system/"/>
    <id>https://kerita.me/06/24/fe-attack/1-system/</id>
    <published>2021-06-24T00:00:00.000Z</published>
    <updated>2021-07-26T11:43:44.480Z</updated>
    
    
    <summary type="html">&lt;p&gt;2021 年前端基础知识体系，包括入门前端应该学习的专业知识与项目过需要的知识。&lt;/p&gt;</summary>
    
    
    
    <category term="前端进击笔记" scheme="https://kerita.me/categories/%E5%89%8D%E7%AB%AF%E8%BF%9B%E5%87%BB%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="体系" scheme="https://kerita.me/tags/%E4%BD%93%E7%B3%BB/"/>
    
  </entry>
  
  <entry>
    <title>什么是 npx？</title>
    <link href="https://kerita.me/06/23/2021/npx/"/>
    <id>https://kerita.me/06/23/2021/npx/</id>
    <published>2021-06-23T00:00:00.000Z</published>
    <updated>2021-07-26T11:43:44.476Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;什么是-npx&quot;&gt;&lt;a href=&quot;#什么是-npx&quot; class=&quot;headerlink&quot; title=&quot;什么是 npx&quot;&gt;&lt;/a&gt;什么是 npx&lt;/h2&gt;&lt;p&gt;npx 是一个用来运行 npm 包的工具，而无需全局安装该 npm 包，它随着 npm 5.2 版本发布。&lt;/p&gt;</summary>
    
    
    
    <category term="前端" scheme="https://kerita.me/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="工程化" scheme="https://kerita.me/tags/%E5%B7%A5%E7%A8%8B%E5%8C%96/"/>
    
  </entry>
  
</feed>
