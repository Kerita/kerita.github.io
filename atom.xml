<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Kerita</title>
  <icon>https://kerita.me/icon.webp</icon>
  <subtitle>自律谦逊，承担责任，推迟满足感，你要热爱它</subtitle>
  <link href="https://kerita.me/atom.xml" rel="self"/>
  
  <link href="https://kerita.me/"/>
  <updated>2021-08-06T14:37:48.717Z</updated>
  <id>https://kerita.me/</id>
  
  <author>
    <name>Kerita</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>sourceType 错误</title>
    <link href="https://kerita.me/08/03/2021/babel-sourceType/"/>
    <id>https://kerita.me/08/03/2021/babel-sourceType/</id>
    <published>2021-08-03T00:00:00.000Z</published>
    <updated>2021-08-06T14:37:48.717Z</updated>
    
    
    <summary type="html">&lt;p&gt;升级 Babel 配置过程除了遇到 &lt;a href=&quot;/07/30/2021/replaceAll-is-not-a-function/#more&quot;&gt;&lt;code&gt;replaceAll-is-not-a-function&lt;/code&gt;&lt;/a&gt; 问题，还遇到关于 Babel sourceType 配置的问题。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>React 合成事件源码阅读</title>
    <link href="https://kerita.me/08/03/read-source-code/react-event/"/>
    <id>https://kerita.me/08/03/read-source-code/react-event/</id>
    <published>2021-08-03T00:00:00.000Z</published>
    <updated>2021-08-06T14:37:48.781Z</updated>
    
    
    <summary type="html">&lt;p&gt;React 合成事件是基于事件委托机制，构建的自定义事件体系。将需要监听的事件类型都收集起来放在 document 元素上，待事件触发通过 &lt;code&gt;event.target&lt;/code&gt; 将事件分发给相关元素。&lt;/p&gt;
&lt;p&gt;以下是分发时收集相关元素代码，包括两次遍历和获取父元素：&lt;/p&gt;</summary>
    
    
    
    <category term="源码阅读" scheme="https://kerita.me/categories/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
    
  </entry>
  
  <entry>
    <title>setState 源码阅读</title>
    <link href="https://kerita.me/08/03/read-source-code/setState/"/>
    <id>https://kerita.me/08/03/read-source-code/setState/</id>
    <published>2021-08-03T00:00:00.000Z</published>
    <updated>2021-08-06T14:37:48.781Z</updated>
    
    
    <summary type="html">&lt;p&gt;在理解&lt;a href=&quot;/07/29/dive-in-react/11-setState/&quot;&gt;setState 是同步还是异步的&lt;/a&gt; 时，梳理下 setState 的源码逻辑，如下：&lt;/p&gt;</summary>
    
    
    
    <category term="源码阅读" scheme="https://kerita.me/categories/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
    
  </entry>
  
  <entry>
    <title>React 合成事件机制</title>
    <link href="https://kerita.me/08/02/dive-in-react/17-event/"/>
    <id>https://kerita.me/08/02/dive-in-react/17-event/</id>
    <published>2021-08-02T00:00:00.000Z</published>
    <updated>2021-08-06T14:37:48.737Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;JavaScript-事件模型&quot;&gt;&lt;a href=&quot;#JavaScript-事件模型&quot; class=&quot;headerlink&quot; title=&quot;JavaScript 事件模型&quot;&gt;&lt;/a&gt;JavaScript 事件模型&lt;/h2&gt;&lt;p&gt;在 JavaScript DOM 事件模型中，事件的传播分为三个阶段：&lt;br&gt;1.事件捕获阶段&lt;br&gt;2.目标阶段&lt;br&gt;3.事件冒泡阶段&lt;/p&gt;
&lt;p&gt;因而，对于大部分事件类型，当子元素发生事件时，只要父元素通过监听相同的事件类型，也能知道子元素事件的发生。&lt;/p&gt;</summary>
    
    
    
    <category term="深入浅出 React" scheme="https://kerita.me/categories/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA-React/"/>
    
    
    <category term="React" scheme="https://kerita.me/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>babel/preset-env 文档</title>
    <link href="https://kerita.me/08/02/2021/preset-env/"/>
    <id>https://kerita.me/08/02/2021/preset-env/</id>
    <published>2021-08-02T00:00:00.000Z</published>
    <updated>2021-08-06T14:37:48.733Z</updated>
    
    
    <summary type="html">&lt;p&gt;&lt;code&gt;@babel/preset-env&lt;/code&gt; is a smart preset that allows you to use the latest JavaScript without needing to micromanage which syntax transforms (and optionally, browser polyfills) are needed by your target environment(s). This both makes your life easier and JavaScript bundles smaller!&lt;/p&gt;
&lt;p&gt;&lt;code&gt;@babel/preset-env&lt;/code&gt; 是一个智能的预设，让你在使用最新的 JavaScript 的同时，无需关心那个语法转换或者浏览器 polyfill 是被目标浏览器所需要。这会让你的生活更美好，同时让 JavaScript bundles 更小。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#install&quot;&gt;Install&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#how-does-it-work&quot;&gt;How Does it Work?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#browserslist-integration&quot;&gt;Browserslist Integration&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#options&quot;&gt;Options&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="Babel" scheme="https://kerita.me/categories/Babel/"/>
    
    
  </entry>
  
  <entry>
    <title>什么是微前端</title>
    <link href="https://kerita.me/08/01/2021/micro-fe/"/>
    <id>https://kerita.me/08/01/2021/micro-fe/</id>
    <published>2021-08-01T00:00:00.000Z</published>
    <updated>2021-08-06T14:37:48.733Z</updated>
    
    
    <summary type="html">&lt;p&gt;微前端的理念源自微服务，使用一个主应用作为主体框架和微应用加载器，根据不用的路由加载不同的微应用。微应用之间做到技术隔离，在展示上却是统一的。&lt;/p&gt;
&lt;p&gt;微前端主要用来解决单体应用在相对长的时间跨度下，从一个普通应用变成一个巨石应用(Frontend Monolith)后，随着而来的应用不可维护问题。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>从 replaceAll is not a function 说起</title>
    <link href="https://kerita.me/07/30/2021/replaceAll-is-not-a-function/"/>
    <id>https://kerita.me/07/30/2021/replaceAll-is-not-a-function/</id>
    <published>2021-07-30T00:00:00.000Z</published>
    <updated>2021-08-06T14:37:48.733Z</updated>
    
    
    <summary type="html">&lt;p&gt;开发一个项目的时候，发现 @babel/preset-env 的配置如下：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#39;@babel&amp;#x2F;preset-env&amp;#39;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    useBuiltIns: false,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    targets: &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      chrome: 43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;],&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;使用这种配置，没有利用 &lt;code&gt;@babel/preset-env&lt;/code&gt; 根据 &lt;code&gt;targets&lt;/code&gt; 自动引入 polyfill 的能力，而是开发者手动引入。&lt;/p&gt;</summary>
    
    
    
    <category term="Babel" scheme="https://kerita.me/categories/Babel/"/>
    
    
  </entry>
  
  <entry>
    <title>setState 是同步还是异步的</title>
    <link href="https://kerita.me/07/29/dive-in-react/11-setState/"/>
    <id>https://kerita.me/07/29/dive-in-react/11-setState/</id>
    <published>2021-07-29T00:00:00.000Z</published>
    <updated>2021-08-06T14:37:48.733Z</updated>
    
    
    <summary type="html">&lt;p&gt;在我们使用 class 组件时，基本都会使用到 setState，因为唯有使用 setState 更新数据，才能实现数据驱动视图的效果。&lt;/p&gt;</summary>
    
    
    
    <category term="深入浅出 React" scheme="https://kerita.me/categories/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA-React/"/>
    
    
    <category term="React" scheme="https://kerita.me/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>React 15 的调和</title>
    <link href="https://kerita.me/07/28/dive-in-react/10-reconciliation/"/>
    <id>https://kerita.me/07/28/dive-in-react/10-reconciliation/</id>
    <published>2021-07-28T00:00:00.000Z</published>
    <updated>2021-08-06T14:37:48.733Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;什么是调和（Reconciliation）&quot;&gt;&lt;a href=&quot;#什么是调和（Reconciliation）&quot; class=&quot;headerlink&quot; title=&quot;什么是调和（Reconciliation）&quot;&gt;&lt;/a&gt;什么是调和（Reconciliation）&lt;/h2&gt;&lt;p&gt;React 官方文档如是说：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Virtual DOM 是一种编程概念。在这个概念里，UI 以一种理想化的，或者说“虚拟的”表现形式被保存于内存中，并通过如 ReactDOM 等类库使之与“真实的” DOM 同步。这一过程叫作协调（调和）。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Diff 则是调和过程最重要部分。&lt;/p&gt;</summary>
    
    
    
    <category term="深入浅出 React" scheme="https://kerita.me/categories/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA-React/"/>
    
    
    <category term="React" scheme="https://kerita.me/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>React 的虚拟 DOM</title>
    <link href="https://kerita.me/07/28/dive-in-react/9-virtual-dom/"/>
    <id>https://kerita.me/07/28/dive-in-react/9-virtual-dom/</id>
    <published>2021-07-28T00:00:00.000Z</published>
    <updated>2021-08-06T14:37:48.741Z</updated>
    
    
    <summary type="html">&lt;p&gt;虚拟 DOM 是使用 JS 对象来描述真实 DOM 结构。在数据发生改变时，虚拟 DOM 也发生改变，通过对比新旧虚拟 DOM 结构(diff)，找出二者差异，对真实 DOM 结构做更新(patch)。&lt;/p&gt;</summary>
    
    
    
    <category term="深入浅出 React" scheme="https://kerita.me/categories/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA-React/"/>
    
    
    <category term="React" scheme="https://kerita.me/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>React Hooks 设计思想</title>
    <link href="https://kerita.me/07/27/dive-in-react/6-hooks/"/>
    <id>https://kerita.me/07/27/dive-in-react/6-hooks/</id>
    <published>2021-07-27T00:00:00.000Z</published>
    <updated>2021-08-06T14:37:48.741Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;什么是-Hooks&quot;&gt;&lt;a href=&quot;#什么是-Hooks&quot; class=&quot;headerlink&quot; title=&quot;什么是 Hooks&quot;&gt;&lt;/a&gt;什么是 Hooks&lt;/h2&gt;&lt;p&gt;Hooks 是 React 16.8 版本出现的特性，它是诸如 useState、useEffect 等一系列钩子函数。Hooks 的出现开发者在不需要写 class 组件时，也能具有 state 和其他 React 特性，函数组件从 stateless 变成 stateful。&lt;/p&gt;</summary>
    
    
    
    <category term="深入浅出 React" scheme="https://kerita.me/categories/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA-React/"/>
    
    
    <category term="React" scheme="https://kerita.me/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>React 生命周期</title>
    <link href="https://kerita.me/07/26/dive-in-react/2-lifecycle/"/>
    <id>https://kerita.me/07/26/dive-in-react/2-lifecycle/</id>
    <published>2021-07-26T00:00:00.000Z</published>
    <updated>2021-08-06T14:37:48.737Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;React-生命周期&quot;&gt;&lt;a href=&quot;#React-生命周期&quot; class=&quot;headerlink&quot; title=&quot;React 生命周期&quot;&gt;&lt;/a&gt;React 生命周期&lt;/h2&gt;&lt;p&gt;React 是一个构建用户界面的 JavaScript 库，其核心的 Virtual DOM 是由生命周期的 render 方法生成的。初始化时，render 方法生成 Virtual DOM 交给 ReactDOM.render 方法渲染成真实 DOM；更新时， render 方法生成的新 Virtual DOM 与旧 Virtual DOM 进行比较，针对差异部分 ReactDOM.render 对真实 DOM 进行修改。&lt;/p&gt;
&lt;p&gt;React 生命周期中的 render 在其中扮演着 Virtual DOM 生成的关键角色，其他生命周期则像是 render 方法的辅助，做数据的初始化或者修改，辅助 render 方法完成 Virtual DOM 的生成。&lt;/p&gt;</summary>
    
    
    
    <category term="深入浅出 React" scheme="https://kerita.me/categories/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA-React/"/>
    
    
    <category term="React" scheme="https://kerita.me/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>React 组件之间数据传递</title>
    <link href="https://kerita.me/07/26/dive-in-react/4-data/"/>
    <id>https://kerita.me/07/26/dive-in-react/4-data/</id>
    <published>2021-07-26T00:00:00.000Z</published>
    <updated>2021-08-06T14:37:48.741Z</updated>
    
    
    <summary type="html">&lt;p&gt;React 是一个构建用户界面的 JavaScript 库，其思想是用数据驱动视图。&lt;/p&gt;
&lt;p&gt;可以用如下代码来表示：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;UI &amp;#x3D; render(data)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;data 就是 React 界面的核心。在渲染用户界面时，data 不是静止不动的，它可能需要在父子组件之间共享、可能需要在兄弟组件共享以及其他层次关系的组件之间共享。下面我们就讲 4 种组件间数据传递的方式。&lt;/p&gt;</summary>
    
    
    
    <category term="深入浅出 React" scheme="https://kerita.me/categories/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA-React/"/>
    
    
    <category term="React" scheme="https://kerita.me/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>什么是函数式编程</title>
    <link href="https://kerita.me/07/25/2021/func/"/>
    <id>https://kerita.me/07/25/2021/func/</id>
    <published>2021-07-25T00:00:00.000Z</published>
    <updated>2021-08-06T14:37:48.733Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;什么是函数式编程&quot;&gt;&lt;a href=&quot;#什么是函数式编程&quot; class=&quot;headerlink&quot; title=&quot;什么是函数式编程&quot;&gt;&lt;/a&gt;什么是函数式编程&lt;/h2&gt;&lt;p&gt;函数式编程是一种编程范式。编程范式是基于程序语言的特点对程序语言进行分类的一种方式，常见的编程范式有：函数式编程、指令式编程、过程式编程、面向对象编程等等。&lt;/p&gt;
&lt;p&gt;在面向对象编程中，程序则是一系列相互作用的对象，由于方法论的不同，面向对象编程范式又分为基于类编程和基于原型编程。&lt;/p&gt;
&lt;p&gt;函数式编程的理论基础 Lambda 演算。Lambda 演算是一种数学的抽象，是研究函数如何抽象定义、函数如何被引用以及递归的形式系统。一个函数式编程程序会被看作是一个无状态的函数计算的序列，正如函数关心的是数据的映射，函数式编程也是如此。&lt;/p&gt;</summary>
    
    
    
    <category term="React" scheme="https://kerita.me/categories/React/"/>
    
    
  </entry>
  
  <entry>
    <title>什么是 JSX</title>
    <link href="https://kerita.me/07/23/dive-in-react/1-jsx/"/>
    <id>https://kerita.me/07/23/dive-in-react/1-jsx/</id>
    <published>2021-07-23T00:00:00.000Z</published>
    <updated>2021-08-06T14:37:48.733Z</updated>
    
    
    <summary type="html">&lt;p&gt;在使用 React 开发项目的过程，我们都会使用 JSX 来描述 UI。今天我们就来聊聊什么是 JSX。&lt;/p&gt;</summary>
    
    
    
    <category term="深入浅出 React" scheme="https://kerita.me/categories/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA-React/"/>
    
    
    <category term="React" scheme="https://kerita.me/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>React 和 Vue 有什么异同</title>
    <link href="https://kerita.me/07/21/fe-attack/16-react-vs-vue/"/>
    <id>https://kerita.me/07/21/fe-attack/16-react-vs-vue/</id>
    <published>2021-07-21T00:00:00.000Z</published>
    <updated>2021-08-06T14:37:48.761Z</updated>
    
    
    <summary type="html">&lt;p&gt;React 和 Vue 是当下最流行的两大前端框架，今天我们来对比下他们有什么异同。&lt;/p&gt;</summary>
    
    
    
    <category term="前端进击笔记" scheme="https://kerita.me/categories/%E5%89%8D%E7%AB%AF%E8%BF%9B%E5%87%BB%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>前端组件化和模块化</title>
    <link href="https://kerita.me/07/20/fe-attack/14-design/"/>
    <id>https://kerita.me/07/20/fe-attack/14-design/</id>
    <published>2021-07-20T00:00:00.000Z</published>
    <updated>2021-08-06T14:37:48.757Z</updated>
    
    
    <summary type="html">&lt;p&gt;前端有两个大方向一定要掌握，一是组件化和模块化，二是工程化，今天我们来聊一聊组件化和模块化。组件化和模块化满足了软件工程低内聚、高耦合、代码模块化的原则，提高代码的可重用性和可复用性，是提高工作效率的重要法宝。&lt;/p&gt;</summary>
    
    
    
    <category term="前端进击笔记" scheme="https://kerita.me/categories/%E5%89%8D%E7%AB%AF%E8%BF%9B%E5%87%BB%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>单页应用与前端路由库设计原理</title>
    <link href="https://kerita.me/07/18/fe-attack/12-spa/"/>
    <id>https://kerita.me/07/18/fe-attack/12-spa/</id>
    <published>2021-07-18T00:00:00.000Z</published>
    <updated>2021-08-06T14:37:48.757Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;什么是单页应用&quot;&gt;&lt;a href=&quot;#什么是单页应用&quot; class=&quot;headerlink&quot; title=&quot;什么是单页应用&quot;&gt;&lt;/a&gt;什么是单页应用&lt;/h2&gt;&lt;p&gt;单页应用就是只有一个 HTML 页面的应用，页面 URL 的变化只是通过浏览器 API 修改，浏览器不会向服务器请求新的 HTML 的，而是通过 JS 控制不同的 URL 渲染相应的内容。&lt;/p&gt;
&lt;p&gt;单页应用相比传统的 JSP、PHP 多页应用，在切换页面时无需刷新，只需进行局部更新，加载内容快，页面的数据状态和用户数据依然保留。但是，因为单页应用返回的是一个 body 空白的 HTML 文件，HTML 内容由 JS 生成，搜索引擎无法获取到，可能影响搜索引擎排名。&lt;/p&gt;</summary>
    
    
    
    <category term="前端进击笔记" scheme="https://kerita.me/categories/%E5%89%8D%E7%AB%AF%E8%BF%9B%E5%87%BB%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>前端模块标准和 Webpack 工作流程</title>
    <link href="https://kerita.me/07/18/fe-attack/13-module/"/>
    <id>https://kerita.me/07/18/fe-attack/13-module/</id>
    <published>2021-07-18T00:00:00.000Z</published>
    <updated>2021-08-06T14:37:48.757Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;CommonJS-与-ES6-Module-的区别&quot;&gt;&lt;a href=&quot;#CommonJS-与-ES6-Module-的区别&quot; class=&quot;headerlink&quot; title=&quot;CommonJS 与 ES6 Module 的区别&quot;&gt;&lt;/a&gt;CommonJS 与 ES6 Module 的区别&lt;/h2&gt;&lt;p&gt;可以参考本博客之前的文章 &lt;a href=&quot;/04/03/2021/module/&quot;&gt;CommonJS 与 ES6 Module 的区别&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="前端进击笔记" scheme="https://kerita.me/categories/%E5%89%8D%E7%AB%AF%E8%BF%9B%E5%87%BB%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>几种常见的大前端应用</title>
    <link href="https://kerita.me/07/16/fe-attack/11-fe/"/>
    <id>https://kerita.me/07/16/fe-attack/11-fe/</id>
    <published>2021-07-16T00:00:00.000Z</published>
    <updated>2021-08-06T14:37:48.757Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;什么是-Hybrid-App&quot;&gt;&lt;a href=&quot;#什么是-Hybrid-App&quot; class=&quot;headerlink&quot; title=&quot;什么是 Hybrid App&quot;&gt;&lt;/a&gt;什么是 Hybrid App&lt;/h2&gt;&lt;p&gt;Hybrid App 是融合了 Native App 和 Web App 的混合 App，Web App 运行在 Native App 提供的 WebView 中，Web App 通过中间的 bridge 调用 Native 的功能。传统的 Hybrid App 开发技术有 Cordova，Phone Gap 和 Ionic。&lt;/p&gt;</summary>
    
    
    
    <category term="前端进击笔记" scheme="https://kerita.me/categories/%E5%89%8D%E7%AB%AF%E8%BF%9B%E5%87%BB%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
</feed>
